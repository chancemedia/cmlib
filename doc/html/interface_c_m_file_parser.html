<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CMLIB: CMFileParser Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CMFileParser Interface Reference</h1><!-- doxytag: class="CMFileParser" --><!-- doxytag: inherits="CMClass" -->
<p>File parser interface.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for CMFileParser:</div>
<div class="dynsection">
 <div class="center">
  <img src="interface_c_m_file_parser.png" usemap="#CMFileParser_map" alt=""/>
  <map id="CMFileParser_map" name="CMFileParser_map">
<area href="interface_c_m_class.html" alt="CMClass" shape="rect" coords="101,0,192,24"/>
<area href="class_c_m_file_c_s_v.html" alt="CMFileCSV" shape="rect" coords="0,112,91,136"/>
<area href="class_c_m_file_i_c_a_l.html" alt="CMFileICAL" shape="rect" coords="101,112,192,136"/>
<area href="class_c_m_file_v_c_f.html" alt="CMFileVCF" shape="rect" coords="202,112,293,136"/>
</map>
 </div>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#ad2bae0efe64fd67aafc2baad67dbf120">add</a> ($item=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add/write a new item to the class.  <a href="#ad2bae0efe64fd67aafc2baad67dbf120"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#ad51812b2aa2b726688c27570a13d3937">finishWriteFile</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close and flush the writing file handle.  <a href="#ad51812b2aa2b726688c27570a13d3937"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#ab119de9fb3a6520c093501aa941ebdeb">getInternetMediaTypes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get internet media type (originally MIME type.).  <a href="#ab119de9fb3a6520c093501aa941ebdeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#a2afd230e2b31e9ab339dd9879f17bd7d">getStandardExtensions</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The standard file extensions for this file parser.  <a href="#a2afd230e2b31e9ab339dd9879f17bd7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#a3d23f68f155fbcaaadaaa90665b3800d">isBinary</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binary file type.  <a href="#a3d23f68f155fbcaaadaaa90665b3800d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#aee954a9976108ebcec479fa4a4983de7">isCaching</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <span style="color: MediumBlue"><code>true</code></span> if this file parser instance is caching.  <a href="#aee954a9976108ebcec479fa4a4983de7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#aac2d51edbe345fb73e63bafd7d505213">iterateFile</a> ($uri, $a=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input a file in peices.  <a href="#aac2d51edbe345fb73e63bafd7d505213"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#affa1184c8126ba8154b574077d9db3ec">iterateString</a> ($str, $a=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input a string in peices.  <a href="#affa1184c8126ba8154b574077d9db3ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#a19c703ce1e7d565fae99689f33383e1e">next</a> ($options=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interate to the next line or object.  <a href="#a19c703ce1e7d565fae99689f33383e1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#a84682117d78dcfc279db48d8aa3afa37">prepareWriteFile</a> ($uri, $a=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare the output write file.  <a href="#a84682117d78dcfc279db48d8aa3afa37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#acb888f8443da8dcc9897d29fc4cb0b87">readFile</a> ($uri, $a=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load entire file.  <a href="#acb888f8443da8dcc9897d29fc4cb0b87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#abd982e59b25e4cbee10131891116e29e">readString</a> ($str, $a=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load an entire string.  <a href="#abd982e59b25e4cbee10131891116e29e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#aa96227453b5fe69a6749fdb95f32cc89">setCache</a> ($mode=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn on/off the caching for this parse.  <a href="#aa96227453b5fe69a6749fdb95f32cc89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#ac3be5cefee1a15eced043f9c32674465">writeFile</a> ($url, $a=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write rendered output to a file.  <a href="#ac3be5cefee1a15eced043f9c32674465"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_m_file_parser.html#a993b95c56b50a5e314e292d79fc068c5">writeString</a> ($a=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the rendered output.  <a href="#a993b95c56b50a5e314e292d79fc068c5"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>File parser interface. </p>
<h2><a class="anchor" id="cmfileparser_description">
Description</a></h2>
<p>Classes that implement this interface are required to implement all the method, however are not required to return a non-<span style="color: MediumBlue"><code>false</code></span> value for method that either do not apply, are not available or caused some kind of error.</p>
<h2><a class="anchor" id="cmfileparser_usage">
Usage</a></h2>
<p>You are free to write your own file parsing classes from this interface but the interface alone has no purpose in your application.</p>
<h2><a class="anchor" id="cmfileparser_example">
Example</a></h2>
<p>See subclasses for specific examples.</p>
<h2><a class="anchor" id="cmfileparser_cache">
Caching vs Noncaching File Parsers</a></h2>
<p>Some file parsers do not hold any information about the file they are reading from or writing to and merely act as a standard interface for the reading and writing of the file. These are called noncaching parsers. Noncaching file parser may not implement all of the methods in this interface, such as <a class="el" href="interface_c_m_file_parser.html#ac3be5cefee1a15eced043f9c32674465" title="Write rendered output to a file.">writeFile()</a> or <a class="el" href="interface_c_m_file_parser.html#a993b95c56b50a5e314e292d79fc068c5" title="Return the rendered output.">writeString()</a> which renders the output of the class storage for that file format.</p>
<p>On the other hand caching file parsers will maintain an internal storage of data that can be manipulated and committed or read from a file in one go. This can prove troublesome for large files. For example the CSV file format is text and in most cases quite small files, however if you had to process a file that was 100MB or a value above the amount of memory PHP is allowed to allcate your program would stop functioning properly. The solution for this is to separate methods for reading/writing and entire file with methods for reading/writing a single 'item' at a time. In the case of CSV the 'item' would be a single line.</p>
<p>Here is a table showing the methods that are usually available with each type of file parser: </p>
<table class="doxtable">
<tr>
<th>Function </th><th>Caching Parser </th><th>Noncaching Parser </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="interface_c_m_file_parser.html#ad2bae0efe64fd67aafc2baad67dbf120" title="Add/write a new item to the class.">add()</a> </td><td>Yes </td><td>Yes </td><td>Add a new 'item'. The 'item' depends on what the file parser handles, but for example if the class was <a class="el" href="class_c_m_file_c_s_v.html" title="Class for handling CSV (comma-separated values) files.">CMFileCSV</a> the <a class="el" href="interface_c_m_file_parser.html#ad2bae0efe64fd67aafc2baad67dbf120" title="Add/write a new item to the class.">add()</a> would take an array representing the field to write to the file as a single line.  </td></tr>
<tr>
<td><a class="el" href="interface_c_m_file_parser.html#aac2d51edbe345fb73e63bafd7d505213" title="Input a file in peices.">iterateFile()</a> </td><td>Yes </td><td>Yes </td><td>Open a file handle and wait for <a class="el" href="interface_c_m_file_parser.html#a19c703ce1e7d565fae99689f33383e1e" title="Interate to the next line or object.">next()</a>.  </td></tr>
<tr>
<td><a class="el" href="interface_c_m_file_parser.html#affa1184c8126ba8154b574077d9db3ec" title="Input a string in peices.">iterateString()</a> </td><td>Yes </td><td>Yes </td><td>Assign a string but do not start reading it until a <a class="el" href="interface_c_m_file_parser.html#a19c703ce1e7d565fae99689f33383e1e" title="Interate to the next line or object.">next()</a> is invoked.  </td></tr>
<tr>
<td><a class="el" href="interface_c_m_file_parser.html#a84682117d78dcfc279db48d8aa3afa37" title="Prepare the output write file.">prepareWriteFile()</a> </td><td>No </td><td>Yes </td><td>For noncaching file parsers this will initiate the output file handle which is performing the reverse of <a class="el" href="interface_c_m_file_parser.html#aac2d51edbe345fb73e63bafd7d505213" title="Input a file in peices.">iterateFile()</a> then use <a class="el" href="interface_c_m_file_parser.html#ad2bae0efe64fd67aafc2baad67dbf120" title="Add/write a new item to the class.">add()</a> to write each item to the output file.  </td></tr>
<tr>
<td><a class="el" href="interface_c_m_file_parser.html#acb888f8443da8dcc9897d29fc4cb0b87" title="Load entire file.">readFile()</a> </td><td>Yes </td><td>No </td><td>Process an entire file.  </td></tr>
<tr>
<td><a class="el" href="interface_c_m_file_parser.html#abd982e59b25e4cbee10131891116e29e" title="Load an entire string.">readString()</a> </td><td>Yes </td><td>No </td><td>Process an entire string.  </td></tr>
<tr>
<td><a class="el" href="interface_c_m_file_parser.html#ac3be5cefee1a15eced043f9c32674465" title="Write rendered output to a file.">writeFile()</a> </td><td>Yes </td><td>No </td><td>Render the internal storage and write the whole thing to an output file.  </td></tr>
<tr>
<td><a class="el" href="interface_c_m_file_parser.html#a993b95c56b50a5e314e292d79fc068c5" title="Return the rendered output.">writeString()</a> </td><td>Yes </td><td>No </td><td>Render the internal storage and return it.  </td></tr>
</table>
<dl class="author"><dt><b>Author:</b></dt><dd>Elliot Chance </dd></dl>

<p>Definition at line <a class="el" href="_c_m_file_parser_8php_source.html#l00100">100</a> of file <a class="el" href="_c_m_file_parser_8php_source.html">CMFileParser.php</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad2bae0efe64fd67aafc2baad67dbf120"></a><!-- doxytag: member="CMFileParser::add" ref="ad2bae0efe64fd67aafc2baad67dbf120" args="($item=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">add </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>item</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add/write a new item to the class. </p>
<p>This method is avilable to caching and noncaching file parsers. In the case of a caching file parser the $item will be added to an internal storage stack. In the case of a noncaching file parser the $item will be processed and commited directly to the file, this means you must use <a class="el" href="interface_c_m_file_parser.html#ac3be5cefee1a15eced043f9c32674465" title="Write rendered output to a file.">writeFile()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$item</em>&nbsp;</td><td>New item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>true</code></span> on success, otherwise <span style="color: MediumBlue"><code>false</code></span>. </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#ad2bae0efe64fd67aafc2baad67dbf120">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#ad2bae0efe64fd67aafc2baad67dbf120">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#ad2bae0efe64fd67aafc2baad67dbf120">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="ad51812b2aa2b726688c27570a13d3937"></a><!-- doxytag: member="CMFileParser::finishWriteFile" ref="ad51812b2aa2b726688c27570a13d3937" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">finishWriteFile </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close and flush the writing file handle. </p>
<p>This is always recommended, but in some cases when the PHP script finishes the file handles will be flushed and closed for you. Opening a read file handle on a file that has no been closed yet will cause problems.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always <span style="color: MediumBlue"><code>true</code></span>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="interface_c_m_file_parser.html#a84682117d78dcfc279db48d8aa3afa37" title="Prepare the output write file.">prepareWriteFile()</a> </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#ad51812b2aa2b726688c27570a13d3937">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#ad51812b2aa2b726688c27570a13d3937">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#ad51812b2aa2b726688c27570a13d3937">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="ab119de9fb3a6520c093501aa941ebdeb"></a><!-- doxytag: member="CMFileParser::getInternetMediaTypes" ref="ab119de9fb3a6520c093501aa941ebdeb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">getInternetMediaTypes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get internet media type (originally MIME type.). </p>
<p>An Internet media type, originally called a MIME type after MIME and sometimes a <code>Content-type</code> after the name of a header in several protocols whose value is such a type, is a two-part identifier for file formats on the Internet. The identifiers were originally defined in <code>RFC 2046</code> for use in e-mail sent through SMTP, but their use has expanded to other protocols such as HTTP, RTP and SIP.</p>
<p>A media type is composed of at least two parts: a type, a subtype, and one or more optional parameters. For example, subtypes of text type have an optional charset parameter that can be included to indicate the character encoding, and subtypes of multipart type often define a boundary between parts.</p>
<p>Types or subtypes that begin with <code>x-</code> are nonstandard (they are not registered with IANA). Subtypes that begin with <code>vnd.</code> are vendor-specific; subtypes in the personal or vanity tree begin with <code>prs.</code>.</p>
<p>MIME is short for Multipurpose Internet Mail Extensions, a specification for formatting non-ASCII messages so that they can be sent over the Internet. Many e-mail clients now support MIME, which enables them to send and receive graphics, audio, and video files via the Internet mail system. In addition, MIME supports messages in character sets other than ASCII.</p>
<p><a href="http://en.wikipedia.org/wiki/Internet_media_type">http://en.wikipedia.org/wiki/Internet_media_type</a></p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of internet media types. </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#ab119de9fb3a6520c093501aa941ebdeb">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#ab119de9fb3a6520c093501aa941ebdeb">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#ab119de9fb3a6520c093501aa941ebdeb">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="a2afd230e2b31e9ab339dd9879f17bd7d"></a><!-- doxytag: member="CMFileParser::getStandardExtensions" ref="a2afd230e2b31e9ab339dd9879f17bd7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">getStandardExtensions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The standard file extensions for this file parser. </p>
<p>The first element in the array returned is assumed to be the default file extension.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Array of file extensions that contain the dot (.) where needed. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_c_m_file_type.html#a16cebf908ce8dd870f076eb0299e1773" title="Get the class name for an extension.">CMFileType::GetClassForExtension()</a>. </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#a2afd230e2b31e9ab339dd9879f17bd7d">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#a2afd230e2b31e9ab339dd9879f17bd7d">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#a2afd230e2b31e9ab339dd9879f17bd7d">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="a3d23f68f155fbcaaadaaa90665b3800d"></a><!-- doxytag: member="CMFileParser::isBinary" ref="a3d23f68f155fbcaaadaaa90665b3800d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isBinary </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Binary file type. </p>
<p>Some file types can be both binary or text. This function is constant and returns <span style="color: MediumBlue"><code>true</code></span> if the file type this class deals with <em>can be</em>, but is not limited to a binary type.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>true</code></span> if the file type this class handles (regardless of the file it is actually handling) is allowed to be binary. </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#a3d23f68f155fbcaaadaaa90665b3800d">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#a3d23f68f155fbcaaadaaa90665b3800d">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#a3d23f68f155fbcaaadaaa90665b3800d">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="aee954a9976108ebcec479fa4a4983de7"></a><!-- doxytag: member="CMFileParser::isCaching" ref="aee954a9976108ebcec479fa4a4983de7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isCaching </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return <span style="color: MediumBlue"><code>true</code></span> if this file parser instance is caching. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>true</code></span> or <span style="color: MediumBlue"><code>false</code></span> for on and off respectivly. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="interface_c_m_file_parser.html#aa96227453b5fe69a6749fdb95f32cc89" title="Turn on/off the caching for this parse.">setCache()</a> </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#aee954a9976108ebcec479fa4a4983de7">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#aee954a9976108ebcec479fa4a4983de7">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#aee954a9976108ebcec479fa4a4983de7">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="aac2d51edbe345fb73e63bafd7d505213"></a><!-- doxytag: member="CMFileParser::iterateFile" ref="aac2d51edbe345fb73e63bafd7d505213" args="($uri, $a=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterateFile </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>a</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Input a file in peices. </p>
<p>The purpose of this method is when you are dealing with large input files. Or when the file parsing class does not handle its own storage (noncaching.) This method simply opens the file and requires the code to invoke <a class="el" href="interface_c_m_file_parser.html#a19c703ce1e7d565fae99689f33383e1e" title="Interate to the next line or object.">next()</a> as needed to deal with each line or object.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you attempt to use <a class="el" href="interface_c_m_file_parser.html#acb888f8443da8dcc9897d29fc4cb0b87" title="Load entire file.">readFile()</a> the entire file will be processed into RAM according to the action of that class and how it stores the data.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$uri</em>&nbsp;</td><td>URI can be a URL, relative or absolute path. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$a</em>&nbsp;</td><td>An associative array of extra options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>true</code></span> if the file was opened and is ready to start reading from, otherwise <span style="color: MediumBlue"><code>false</code></span>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>error() </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#aac2d51edbe345fb73e63bafd7d505213">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#aac2d51edbe345fb73e63bafd7d505213">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#a7f957ffafef16bd9f730e359e8192f49">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="affa1184c8126ba8154b574077d9db3ec"></a><!-- doxytag: member="CMFileParser::iterateString" ref="affa1184c8126ba8154b574077d9db3ec" args="($str, $a=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterateString </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>a</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Input a string in peices. </p>
<p>This method works in the same way as <a class="el" href="interface_c_m_file_parser.html#aac2d51edbe345fb73e63bafd7d505213" title="Input a file in peices.">iterateFile()</a> but works with the string provided rather than an input file. The size limit $str is upto PHP limits, if you are dealing with large files consider using temporary disk files or temporary database storage.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you attempt to use <a class="el" href="interface_c_m_file_parser.html#abd982e59b25e4cbee10131891116e29e" title="Load an entire string.">readString()</a> the entire string will be processed into RAM according to the action of that class and how it stores the data.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$str</em>&nbsp;</td><td>Input string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$a</em>&nbsp;</td><td>An associative array of extra options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>true</code></span> almost always. <span style="color: MediumBlue"><code>false</code></span> is only returned if the class knows ahead of time that the string will not be able to be processed. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>error() </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#affa1184c8126ba8154b574077d9db3ec">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#affa1184c8126ba8154b574077d9db3ec">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#a6a03ee0ad177da298a8491f7c17d9202">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="a19c703ce1e7d565fae99689f33383e1e"></a><!-- doxytag: member="CMFileParser::next" ref="a19c703ce1e7d565fae99689f33383e1e" args="($options=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">next </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interate to the next line or object. </p>
<p>Not all subclasses will implement this, if not it will return <span style="color: MediumBlue"><code>false</code></span>. The prupose of this method is to use in conjuntion with <a class="el" href="interface_c_m_file_parser.html#acb888f8443da8dcc9897d29fc4cb0b87" title="Load entire file.">readFile()</a> to read a single entity - whether it be a line or some other form or entity to the class - without the need to load the entire file directly into the class.</p>
<p>See the documentation for this method in the subclasses to see what it's purpose for that particular class is.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$options</em>&nbsp;</td><td>An optional argument to provide the class with extra options when reciving the next object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>false</code></span> if not avilable or the end of the iteration has been reached. Otherwise the string, number, array, object etc of the next iteration. </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#a19c703ce1e7d565fae99689f33383e1e">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#a19c703ce1e7d565fae99689f33383e1e">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#a19c703ce1e7d565fae99689f33383e1e">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="a84682117d78dcfc279db48d8aa3afa37"></a><!-- doxytag: member="CMFileParser::prepareWriteFile" ref="a84682117d78dcfc279db48d8aa3afa37" args="($uri, $a=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">prepareWriteFile </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>a</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare the output write file. </p>
<p>The <a class="el" href="interface_c_m_file_parser.html#a84682117d78dcfc279db48d8aa3afa37" title="Prepare the output write file.">prepareWriteFile()</a> method only applies to class that are noncaching. <a class="el" href="interface_c_m_file_parser.html#a84682117d78dcfc279db48d8aa3afa37" title="Prepare the output write file.">prepareWriteFile()</a> will create the file to then wait for one or more <a class="el" href="interface_c_m_file_parser.html#ad2bae0efe64fd67aafc2baad67dbf120" title="Add/write a new item to the class.">add()</a> to be issued and the data immediatly purged to the output file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$uri</em>&nbsp;</td><td>A valid PHP URL, relative or absolute path. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$a</em>&nbsp;</td><td>Extra optional options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="interface_c_m_file_parser.html#ad51812b2aa2b726688c27570a13d3937" title="Close and flush the writing file handle.">finishWriteFile()</a> </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#a84682117d78dcfc279db48d8aa3afa37">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#a84682117d78dcfc279db48d8aa3afa37">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#a84682117d78dcfc279db48d8aa3afa37">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="acb888f8443da8dcc9897d29fc4cb0b87"></a><!-- doxytag: member="CMFileParser::readFile" ref="acb888f8443da8dcc9897d29fc4cb0b87" args="($uri, $a=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readFile </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>a</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load entire file. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is only only available to caching file parsers.</dd>
<dd>
For use with large files, use <a class="el" href="interface_c_m_file_parser.html#aac2d51edbe345fb73e63bafd7d505213" title="Input a file in peices.">iterateFile()</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$uri</em>&nbsp;</td><td>Valid PHP URL, relative or absolute path. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$a</em>&nbsp;</td><td>An associative array of extra options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>true</code></span> on successful completion, otherwise <span style="color: MediumBlue"><code>false</code></span>. See error() for a <span style="color: MediumBlue"><code>false</code></span> return. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>error() </dd>
<dd>
<a class="el" href="interface_c_m_file_parser.html#aee954a9976108ebcec479fa4a4983de7" title="Return true if this file parser instance is caching.">isCaching()</a> </dd>
<dd>
setCaching() </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#a64355ed82ca7305a5601ecadcc1b6f4d">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#a64355ed82ca7305a5601ecadcc1b6f4d">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#a64355ed82ca7305a5601ecadcc1b6f4d">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="abd982e59b25e4cbee10131891116e29e"></a><!-- doxytag: member="CMFileParser::readString" ref="abd982e59b25e4cbee10131891116e29e" args="($str, $a=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readString </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>a</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load an entire string. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is only only available to caching file parsers.</dd>
<dd>
For use with large strings, use <a class="el" href="interface_c_m_file_parser.html#affa1184c8126ba8154b574077d9db3ec" title="Input a string in peices.">iterateString()</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$str</em>&nbsp;</td><td>Input string to parse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$a</em>&nbsp;</td><td>An associative array of extra options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>true</code></span> on successful completion, otherwise <span style="color: MediumBlue"><code>false</code></span>. See error() for a <span style="color: MediumBlue"><code>false</code></span> return. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>error() </dd>
<dd>
<a class="el" href="interface_c_m_file_parser.html#aee954a9976108ebcec479fa4a4983de7" title="Return true if this file parser instance is caching.">isCaching()</a> </dd>
<dd>
setCaching() </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#abd982e59b25e4cbee10131891116e29e">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#abd982e59b25e4cbee10131891116e29e">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#abd982e59b25e4cbee10131891116e29e">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="aa96227453b5fe69a6749fdb95f32cc89"></a><!-- doxytag: member="CMFileParser::setCache" ref="aa96227453b5fe69a6749fdb95f32cc89" args="($mode=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setCache </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn on/off the caching for this parse. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$mode</em>&nbsp;</td><td><span style="color: MediumBlue"><code>true</code></span> or <span style="color: MediumBlue"><code>false</code></span> for on and off respectivly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="interface_c_m_file_parser.html#aee954a9976108ebcec479fa4a4983de7" title="Return true if this file parser instance is caching.">isCaching()</a> </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#aa96227453b5fe69a6749fdb95f32cc89">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#aa96227453b5fe69a6749fdb95f32cc89">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#aa96227453b5fe69a6749fdb95f32cc89">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="ac3be5cefee1a15eced043f9c32674465"></a><!-- doxytag: member="CMFileParser::writeFile" ref="ac3be5cefee1a15eced043f9c32674465" args="($url, $a=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">writeFile </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>a</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write rendered output to a file. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is only only available to caching file parsers.</dd></dl>
<p><a class="el" href="interface_c_m_file_parser.html#ac3be5cefee1a15eced043f9c32674465" title="Write rendered output to a file.">writeFile()</a> effectivly does the same thing as <a class="el" href="interface_c_m_file_parser.html#a993b95c56b50a5e314e292d79fc068c5" title="Return the rendered output.">writeString()</a> with the main difference being it writes the rendered output to a given URI.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$url</em>&nbsp;</td><td>Valid PHP URL, relative or absolute path. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$a</em>&nbsp;</td><td>An associative array of extra options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>true</code></span> on successful completion, otherwise <span style="color: MediumBlue"><code>false</code></span>. See error() for a <span style="color: MediumBlue"><code>false</code></span> return. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>error() </dd>
<dd>
<a class="el" href="interface_c_m_file_parser.html#aee954a9976108ebcec479fa4a4983de7" title="Return true if this file parser instance is caching.">isCaching()</a> </dd>
<dd>
setCaching() </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#ab0ac2d7b3f8d52e2dda81db115a96ac4">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#ac3be5cefee1a15eced043f9c32674465">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#ac3be5cefee1a15eced043f9c32674465">CMFileVCF</a>.</p>

</div>
</div>
<a class="anchor" id="a993b95c56b50a5e314e292d79fc068c5"></a><!-- doxytag: member="CMFileParser::writeString" ref="a993b95c56b50a5e314e292d79fc068c5" args="($a=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">writeString </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>a</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the rendered output. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is only only available to caching file parsers.</dd></dl>
<p><a class="el" href="interface_c_m_file_parser.html#a993b95c56b50a5e314e292d79fc068c5" title="Return the rendered output.">writeString()</a> and <a class="el" href="interface_c_m_file_parser.html#ac3be5cefee1a15eced043f9c32674465" title="Write rendered output to a file.">writeFile()</a> do the same thing, but the first returns the value and the second writes that same value to a supplied URI.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$a</em>&nbsp;</td><td>An associative array of extra options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><span style="color: MediumBlue"><code>true</code></span> on successful completion, otherwise <span style="color: MediumBlue"><code>false</code></span>. See error() for a <span style="color: MediumBlue"><code>false</code></span> return. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>error() </dd>
<dd>
<a class="el" href="interface_c_m_file_parser.html#aee954a9976108ebcec479fa4a4983de7" title="Return true if this file parser instance is caching.">isCaching()</a> </dd>
<dd>
setCaching() </dd></dl>

<p>Implemented in <a class="el" href="class_c_m_file_c_s_v.html#a993b95c56b50a5e314e292d79fc068c5">CMFileCSV</a>, <a class="el" href="class_c_m_file_i_c_a_l.html#a993b95c56b50a5e314e292d79fc068c5">CMFileICAL</a>, and <a class="el" href="class_c_m_file_v_c_f.html#a993b95c56b50a5e314e292d79fc068c5">CMFileVCF</a>.</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_m_file_parser_8php_source.html">CMFileParser.php</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
